/**
 * ãƒ¡ãƒ¢é …ç›®ã‚µãƒ¼ãƒ“ã‚¹
 * 
 * ãƒ¡ãƒ¢é …ç›®ã«é–¢ã™ã‚‹ãƒ“ã‚¸ãƒã‚¹ãƒ­ã‚¸ãƒƒã‚¯ã‚’é›†ç´„ã—ãŸã‚µãƒ¼ãƒ“ã‚¹å±¤ã§ã™ã€‚
 * AWS Amplifyã®GraphQLAPIã‚’ãƒ©ãƒƒãƒ—ã—ã¦ã€å‹å®‰å…¨ã§ä½¿ã„ã‚„ã™ã„APIã‚’æä¾›ã—ã¾ã™ã€‚
 * ãƒ—ãƒ¬ã‚¼ãƒ³ãƒ†ãƒ¼ã‚·ãƒ§ãƒ³å±¤ï¼ˆReact ã‚³ãƒ³ãƒãƒ¼ãƒãƒ³ãƒˆï¼‰ã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚¢ã‚¯ã‚»ã‚¹ã®è©³ç´°ã‚’åˆ†é›¢ã—ã¾ã™ã€‚
 */

import { generateClient } from 'aws-amplify/api'
import type { GraphQLResult } from '@aws-amplify/api-graphql'
import type { 
  MemoItem, 
  CreateMemoItemInput, 
  UpdateMemoItemInput, 
  DeleteMemoItemInput,
  MemoItemOperationResult,
  MemoItemListResult
} from '@/types'
import {
  LIST_MEMO_ITEMS,
  GET_MEMO_ITEM,
  CREATE_MEMO_ITEM,
  UPDATE_MEMO_ITEM,
  DELETE_MEMO_ITEM,
  MEMO_ITEM_FILTERS
} from '@/lib/graphql/memoItemQueries'

// GraphQL ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å‹å®šç¾©ï¼ˆAmplify AutoGeneratedå‹ã«åˆã‚ã›ã‚‹ï¼‰
interface AmplifyMemoItem {
  id: string
  name: string
  order: number
  visible?: boolean | null
  createdAt?: string | null
  updatedAt?: string | null
  owner?: string | null
  __typename: string
}

interface ListMemoItemsResponse {
  listMemoItems: {
    items: AmplifyMemoItem[]
    nextToken?: string | null
    __typename: string
  }
}

interface GetMemoItemResponse {
  getMemoItem: AmplifyMemoItem | null
}

interface CreateMemoItemResponse {
  createMemoItem: AmplifyMemoItem
}

interface UpdateMemoItemResponse {
  updateMemoItem: AmplifyMemoItem
}

interface DeleteMemoItemResponse {
  deleteMemoItem: {
    id: string
    createdAt?: string | null
    updatedAt?: string | null
    owner?: string | null
    __typename: string
  }
}

// Amplify GraphQLã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã®ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
const client = generateClient()

/**
 * Amplifyã®MemoItemå‹ã‚’ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®MemoItemå‹ã«å¤‰æ›
 */
function convertAmplifyToMemoItem(amplifyItem: AmplifyMemoItem): MemoItem {
  return {
    id: amplifyItem.id,
    name: amplifyItem.name,
    order: amplifyItem.order,
    visible: amplifyItem.visible ?? true,
    createdAt: amplifyItem.createdAt || undefined,
    updatedAt: amplifyItem.updatedAt || undefined,
    owner: amplifyItem.owner || undefined,
    // Amplifyã§ã¯_versionã¯è‡ªå‹•ç®¡ç†ã•ã‚Œã‚‹ãŸã‚å‰Šé™¤
  }
}

/**
 * ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒ¢é …ç›®ä¸€è¦§ã‚’å–å¾—ã—ã¾ã™
 * 
 * ç¾åœ¨ãƒ­ã‚°ã‚¤ãƒ³ã—ã¦ã„ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ãƒ¡ãƒ¢é …ç›®ã‚’è¡¨ç¤ºé †åºã§ã‚½ãƒ¼ãƒˆã—ã¦å–å¾—ã—ã¾ã™ã€‚
 * Amplifyã®èªè¨¼æ©Ÿèƒ½ã«ã‚ˆã‚Šã€è‡ªå‹•çš„ã«æ‰€æœ‰è€…åˆ¶é™ãŒé©ç”¨ã•ã‚Œã¾ã™ã€‚
 * 
 * @param options.visibleOnly - è¡¨ç¤ºå¯èƒ½ãªé …ç›®ã®ã¿ã‚’å–å¾—ã™ã‚‹ã‹ã©ã†ã‹ï¼ˆãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: trueï¼‰
 * @param options.limit - å–å¾—ã™ã‚‹é …ç›®æ•°ã®ä¸Šé™
 * @param options.nextToken - ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³ç”¨ã®ãƒˆãƒ¼ã‚¯ãƒ³
 * @returns Promise<MemoItemListResult> ãƒ¡ãƒ¢é …ç›®ä¸€è¦§
 * @throws {Error} ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ãŸå ´åˆ
 */
export async function getMemoItems(options: {
  visibleOnly?: boolean
  limit?: number
  nextToken?: string
} = {}): Promise<MemoItemListResult> {
  try {
    const { visibleOnly = true, limit = 100, nextToken } = options
    
    // ãƒ•ã‚£ãƒ«ã‚¿ãƒ¼æ¡ä»¶ã®è¨­å®š
    const filter = visibleOnly ? MEMO_ITEM_FILTERS.VISIBLE_ONLY : undefined
    
    console.log('GraphQLãƒªã‚¯ã‚¨ã‚¹ãƒˆé€ä¿¡:', { filter, limit, nextToken })
    
    const response = await client.graphql({
      query: LIST_MEMO_ITEMS,
      variables: {
        filter,
        limit,
        nextToken
      }
    }) as GraphQLResult<ListMemoItemsResponse>
    
    console.log('GraphQLãƒ¬ã‚¹ãƒãƒ³ã‚¹:', response)
    
    if (!response.data?.listMemoItems) {
      throw new Error('GraphQLãƒ¬ã‚¹ãƒãƒ³ã‚¹ãŒç„¡åŠ¹ã§ã™')
    }
    
    const items = response.data.listMemoItems.items || []
    
    // è¡¨ç¤ºé †åºã§ã‚½ãƒ¼ãƒˆï¼ˆorderãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã®æ˜‡é †ï¼‰
    const sortedItems = items
      .map(convertAmplifyToMemoItem)
      .sort((a: MemoItem, b: MemoItem) => a.order - b.order)
    
    return {
      items: sortedItems,
      hasNextPage: !!response.data.listMemoItems.nextToken,
      nextToken: response.data.listMemoItems.nextToken || undefined
    }
  } catch (error) {
    console.error('ãƒ¡ãƒ¢é …ç›®ã®å–å¾—ã«å¤±æ•—:', error)
    // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', (error as any).errors)
    }
    throw new Error('ãƒ¡ãƒ¢é …ç›®ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ')
  }
}

/**
 * ç‰¹å®šã®ãƒ¡ãƒ¢é …ç›®ã‚’å–å¾—ã—ã¾ã™
 * 
 * @param id - å–å¾—ã™ã‚‹ãƒ¡ãƒ¢é …ç›®ã®ID
 * @returns Promise<MemoItem | null> ãƒ¡ãƒ¢é …ç›®ï¼ˆè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã¯nullï¼‰
 * @throws {Error} ãƒ‡ãƒ¼ã‚¿å–å¾—ã«å¤±æ•—ã—ãŸå ´åˆ
 */
export async function getMemoItem(id: string): Promise<MemoItem | null> {
  try {
    const response = await client.graphql({
      query: GET_MEMO_ITEM,
      variables: { id }
    }) as GraphQLResult<GetMemoItemResponse>
    
    const item = response.data?.getMemoItem
    if (!item) return null
    
    return convertAmplifyToMemoItem(item)
  } catch (error) {
    console.error('ãƒ¡ãƒ¢é …ç›®ã®å–å¾—ã«å¤±æ•—:', error)
    throw new Error('ãƒ¡ãƒ¢é …ç›®ã®å–å¾—ã«å¤±æ•—ã—ã¾ã—ãŸ')
  }
}

/**
 * æ–°ã—ã„ãƒ¡ãƒ¢é …ç›®ã‚’ä½œæˆã—ã¾ã™
 * 
 * @param input - ä½œæˆã™ã‚‹ãƒ¡ãƒ¢é …ç›®ã®æƒ…å ±
 * @returns Promise<MemoItemOperationResult> ä½œæˆçµæœ
 */
export async function createMemoItem(input: CreateMemoItemInput): Promise<MemoItemOperationResult> {
  try {
    // å…¥åŠ›å€¤ã®æ¤œè¨¼
    if (!input.name.trim()) {
      return {
        success: false,
        error: 'ãƒ¡ãƒ¢é …ç›®åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'
      }
    }
    
    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã®è¨­å®š
    const itemInput = {
      name: input.name.trim(),
      order: input.order,
      visible: input.visible ?? true
    }
    
    console.log('createMemoItemå…¥åŠ›:', itemInput)
    
    const response = await client.graphql({
      query: CREATE_MEMO_ITEM,
      variables: { 
        input: itemInput,
        // conditionã¯çœç•¥å¯èƒ½
      }
    }) as GraphQLResult<CreateMemoItemResponse>
    
    console.log('createMemoItemãƒ¬ã‚¹ãƒãƒ³ã‚¹:', response)
    
    const createdItem = response.data?.createMemoItem
    if (!createdItem) {
      throw new Error('ä½œæˆã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ')
    }
    
    return {
      success: true,
      item: convertAmplifyToMemoItem(createdItem)
    }
  } catch (error) {
    console.error('ãƒ¡ãƒ¢é …ç›®ã®ä½œæˆã«å¤±æ•—:', error)
    // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', (error as any).errors)
    }
    return {
      success: false,
      error: 'ãƒ¡ãƒ¢é …ç›®ã®ä½œæˆã«å¤±æ•—ã—ã¾ã—ãŸ'
    }
  }
}

/**
 * ãƒ¡ãƒ¢é …ç›®ã‚’æ›´æ–°ã—ã¾ã™
 * 
 * @param input - æ›´æ–°ã™ã‚‹ãƒ¡ãƒ¢é …ç›®ã®æƒ…å ±
 * @returns Promise<MemoItemOperationResult> æ›´æ–°çµæœ
 */
export async function updateMemoItem(input: UpdateMemoItemInput): Promise<MemoItemOperationResult> {
  try {
    // å…¥åŠ›å€¤ã®æ¤œè¨¼
    if (input.name !== undefined && !input.name.trim()) {
      return {
        success: false,
        error: 'ãƒ¡ãƒ¢é …ç›®åã‚’å…¥åŠ›ã—ã¦ãã ã•ã„'
      }
    }
    
    // _versionã¯é™¤å¤–ï¼ˆAmplifyã§è‡ªå‹•ç®¡ç†ï¼‰
    const updateInput = {
      id: input.id,
      ...(input.name && { name: input.name.trim() }),
      ...(input.order !== undefined && { order: input.order }),
      ...(input.visible !== undefined && { visible: input.visible })
    }
    
    console.log('updateMemoItemå…¥åŠ›:', updateInput)
    
    const response = await client.graphql({
      query: UPDATE_MEMO_ITEM,
      variables: { 
        input: updateInput,
        // conditionã¯çœç•¥å¯èƒ½
      }
    }) as GraphQLResult<UpdateMemoItemResponse>
    
    console.log('updateMemoItemãƒ¬ã‚¹ãƒãƒ³ã‚¹:', response)
    
    const updatedItem = response.data?.updateMemoItem
    if (!updatedItem) {
      throw new Error('æ›´æ–°ã•ã‚ŒãŸã‚¢ã‚¤ãƒ†ãƒ ãŒå–å¾—ã§ãã¾ã›ã‚“ã§ã—ãŸ')
    }
    
    return {
      success: true,
      item: convertAmplifyToMemoItem(updatedItem)
    }
  } catch (error) {
    console.error('ãƒ¡ãƒ¢é …ç›®ã®æ›´æ–°ã«å¤±æ•—:', error)
    // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', (error as any).errors)
    }
    return {
      success: false,
      error: 'ãƒ¡ãƒ¢é …ç›®ã®æ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ'
    }
  }
}

/**
 * ãƒ¡ãƒ¢é …ç›®ã‚’å‰Šé™¤ã—ã¾ã™
 * 
 * @param input - å‰Šé™¤ã™ã‚‹ãƒ¡ãƒ¢é …ç›®ã®æƒ…å ±
 * @returns Promise<MemoItemOperationResult> å‰Šé™¤çµæœ
 */
export async function deleteMemoItem(input: DeleteMemoItemInput): Promise<MemoItemOperationResult> {
  try {
    // _versionã¯é™¤å¤–ï¼ˆAmplifyã§è‡ªå‹•ç®¡ç†ï¼‰
    const deleteInput = {
      id: input.id
    }
    
    console.log('deleteMemoItemå…¥åŠ›:', deleteInput)
    
    await client.graphql({
      query: DELETE_MEMO_ITEM,
      variables: { 
        input: deleteInput,
        // conditionã¯çœç•¥å¯èƒ½
      }
    }) as GraphQLResult<DeleteMemoItemResponse>
    
    return {
      success: true
    }
  } catch (error) {
    console.error('ãƒ¡ãƒ¢é …ç›®ã®å‰Šé™¤ã«å¤±æ•—:', error)
    // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', (error as any).errors)
    }
    return {
      success: false,
      error: 'ãƒ¡ãƒ¢é …ç›®ã®å‰Šé™¤ã«å¤±æ•—ã—ã¾ã—ãŸ'
    }
  }
}

/**
 * è¤‡æ•°ã®ãƒ¡ãƒ¢é …ç›®ã®é †åºã‚’ä¸€æ‹¬æ›´æ–°ã—ã¾ã™
 * 
 * ãƒ‰ãƒ©ãƒƒã‚°&ãƒ‰ãƒ­ãƒƒãƒ—æ“ä½œå¾Œã®é †åºä¿å­˜ã§ä½¿ç”¨ã—ã¾ã™ã€‚
 * 
 * @param items - æ›´æ–°ã™ã‚‹ãƒ¡ãƒ¢é …ç›®ã®ãƒªã‚¹ãƒˆ
 * @returns Promise<MemoItemOperationResult> æ›´æ–°çµæœ
 */
export async function bulkUpdateMemoItemOrder(items: Array<{
  id: string
  order: number
}>): Promise<MemoItemOperationResult> {
  console.log('ğŸ”§ bulkUpdateMemoItemOrder é–‹å§‹:', { 
    itemCount: items.length, 
    items: items 
  })

  try {
    if (items.length === 0) {
      console.log('âš ï¸ æ›´æ–°å¯¾è±¡é …ç›®ãŒ0å€‹')
      return {
        success: true
      }
    }

    console.log('ğŸ“¤ GraphQLæ›´æ–°ãƒªã‚¯ã‚¨ã‚¹ãƒˆæº–å‚™ä¸­...')

    // å…¨é …ç›®ã®é †åºã‚’ä¸¦åˆ—ã§æ›´æ–°ï¼ˆ_versionã¯é™¤å¤–ï¼‰
    const updatePromises = items.map((item, index) => {
      console.log(`ğŸ“ æ›´æ–°é …ç›® ${index + 1}/${items.length}:`, item)
      return client.graphql({
        query: UPDATE_MEMO_ITEM,
        variables: { 
          input: { 
            id: item.id,
            order: item.order
          }
        }
      }) as unknown as GraphQLResult<UpdateMemoItemResponse>
    })
    
    console.log('â³ Promise.allå®Ÿè¡Œä¸­...')
    const results = await Promise.all(updatePromises)
    console.log('âœ… å…¨ã¦ã®æ›´æ–°ãŒå®Œäº†:', { 
      successCount: results.length,
      results: results.map(r => !!r.data?.updateMemoItem)
    })
    
    return {
      success: true
    }
  } catch (error) {
    console.error('âŒ ãƒ¡ãƒ¢é …ç›®ã®é †åºæ›´æ–°ã«å¤±æ•—:', error)
    // ã‚¨ãƒ©ãƒ¼ã®è©³ç´°ã‚’ãƒ­ã‚°å‡ºåŠ›
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLã‚¨ãƒ©ãƒ¼ã®è©³ç´°:', (error as any).errors)
    }
    return {
      success: false,
      error: 'ãƒ¡ãƒ¢é …ç›®ã®é †åºæ›´æ–°ã«å¤±æ•—ã—ã¾ã—ãŸ'
    }
  }
}

/**
 * æ–°ã—ã„ãƒ¡ãƒ¢é …ç›®ã®é©åˆ‡ãªé †åºã‚’å–å¾—ã—ã¾ã™
 * 
 * æ—¢å­˜ã®é …ç›®ã®æœ€å¤§orderå€¤ + 1ã‚’è¿”ã—ã¾ã™ã€‚
 * 
 * @returns Promise<number> æ–°ã—ã„é …ç›®ã«è¨­å®šã™ã¹ãé †åº
 */
export async function getNextOrder(): Promise<number> {
  try {
    const result = await getMemoItems({ visibleOnly: false })
    
    if (result.items.length === 0) {
      return 0
    }
    
    const maxOrder = Math.max(...result.items.map(item => item.order))
    return maxOrder + 1
  } catch (error) {
    console.error('æ¬¡ã®é †åºã®å–å¾—ã«å¤±æ•—:', error)
    // ã‚¨ãƒ©ãƒ¼æ™‚ã¯0ã‚’è¿”ã™ï¼ˆæœ€åˆã®é …ç›®ã¨ã—ã¦æ‰±ã†ï¼‰
    return 0
  }
} 