/**
 * メモ項目サービス
 * 
 * メモ項目に関するビジネスロジックを集約したサービス層です。
 * AWS AmplifyのGraphQLAPIをラップして、型安全で使いやすいAPIを提供します。
 * プレゼンテーション層（React コンポーネント）からデータアクセスの詳細を分離します。
 */

import { generateClient } from 'aws-amplify/api'
import type { GraphQLResult } from '@aws-amplify/api-graphql'
import type { 
  MemoItem, 
  CreateMemoItemInput, 
  UpdateMemoItemInput, 
  DeleteMemoItemInput,
  MemoItemOperationResult,
  MemoItemListResult
} from '@/types'
import {
  LIST_MEMO_ITEMS,
  GET_MEMO_ITEM,
  CREATE_MEMO_ITEM,
  UPDATE_MEMO_ITEM,
  DELETE_MEMO_ITEM,
  MEMO_ITEM_FILTERS
} from '@/lib/graphql/memoItemQueries'

// GraphQL レスポンスの型定義（Amplify AutoGenerated型に合わせる）
interface AmplifyMemoItem {
  id: string
  name: string
  order: number
  visible?: boolean | null
  createdAt?: string | null
  updatedAt?: string | null
  owner?: string | null
  __typename: string
}

interface ListMemoItemsResponse {
  listMemoItems: {
    items: AmplifyMemoItem[]
    nextToken?: string | null
    __typename: string
  }
}

interface GetMemoItemResponse {
  getMemoItem: AmplifyMemoItem | null
}

interface CreateMemoItemResponse {
  createMemoItem: AmplifyMemoItem
}

interface UpdateMemoItemResponse {
  updateMemoItem: AmplifyMemoItem
}

interface DeleteMemoItemResponse {
  deleteMemoItem: {
    id: string
    createdAt?: string | null
    updatedAt?: string | null
    owner?: string | null
    __typename: string
  }
}

// Amplify GraphQLクライアントのインスタンス
const client = generateClient()

/**
 * AmplifyのMemoItem型をアプリケーション用のMemoItem型に変換
 */
function convertAmplifyToMemoItem(amplifyItem: AmplifyMemoItem): MemoItem {
  return {
    id: amplifyItem.id,
    name: amplifyItem.name,
    order: amplifyItem.order,
    visible: amplifyItem.visible ?? true,
    createdAt: amplifyItem.createdAt || undefined,
    updatedAt: amplifyItem.updatedAt || undefined,
    owner: amplifyItem.owner || undefined,
    // Amplifyでは_versionは自動管理されるため削除
  }
}

/**
 * ユーザーのメモ項目一覧を取得します
 * 
 * 現在ログインしているユーザーのメモ項目を表示順序でソートして取得します。
 * Amplifyの認証機能により、自動的に所有者制限が適用されます。
 * 
 * @param options.visibleOnly - 表示可能な項目のみを取得するかどうか（デフォルト: true）
 * @param options.limit - 取得する項目数の上限
 * @param options.nextToken - ページネーション用のトークン
 * @returns Promise<MemoItemListResult> メモ項目一覧
 * @throws {Error} データ取得に失敗した場合
 */
export async function getMemoItems(options: {
  visibleOnly?: boolean
  limit?: number
  nextToken?: string
} = {}): Promise<MemoItemListResult> {
  try {
    const { visibleOnly = true, limit = 100, nextToken } = options
    
    // フィルター条件の設定
    const filter = visibleOnly ? MEMO_ITEM_FILTERS.VISIBLE_ONLY : undefined
    
    console.log('GraphQLリクエスト送信:', { filter, limit, nextToken })
    
    const response = await client.graphql({
      query: LIST_MEMO_ITEMS,
      variables: {
        filter,
        limit,
        nextToken
      }
    }) as GraphQLResult<ListMemoItemsResponse>
    
    console.log('GraphQLレスポンス:', response)
    
    if (!response.data?.listMemoItems) {
      throw new Error('GraphQLレスポンスが無効です')
    }
    
    const items = response.data.listMemoItems.items || []
    
    // 表示順序でソート（orderフィールドの昇順）
    const sortedItems = items
      .map(convertAmplifyToMemoItem)
      .sort((a: MemoItem, b: MemoItem) => a.order - b.order)
    
    return {
      items: sortedItems,
      hasNextPage: !!response.data.listMemoItems.nextToken,
      nextToken: response.data.listMemoItems.nextToken || undefined
    }
  } catch (error) {
    console.error('メモ項目の取得に失敗:', error)
    // エラーの詳細をログ出力
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLエラーの詳細:', (error as any).errors)
    }
    throw new Error('メモ項目の取得に失敗しました')
  }
}

/**
 * 特定のメモ項目を取得します
 * 
 * @param id - 取得するメモ項目のID
 * @returns Promise<MemoItem | null> メモ項目（見つからない場合はnull）
 * @throws {Error} データ取得に失敗した場合
 */
export async function getMemoItem(id: string): Promise<MemoItem | null> {
  try {
    const response = await client.graphql({
      query: GET_MEMO_ITEM,
      variables: { id }
    }) as GraphQLResult<GetMemoItemResponse>
    
    const item = response.data?.getMemoItem
    if (!item) return null
    
    return convertAmplifyToMemoItem(item)
  } catch (error) {
    console.error('メモ項目の取得に失敗:', error)
    throw new Error('メモ項目の取得に失敗しました')
  }
}

/**
 * 新しいメモ項目を作成します
 * 
 * @param input - 作成するメモ項目の情報
 * @returns Promise<MemoItemOperationResult> 作成結果
 */
export async function createMemoItem(input: CreateMemoItemInput): Promise<MemoItemOperationResult> {
  try {
    // 入力値の検証
    if (!input.name.trim()) {
      return {
        success: false,
        error: 'メモ項目名を入力してください'
      }
    }
    
    // デフォルト値の設定
    const itemInput = {
      name: input.name.trim(),
      order: input.order,
      visible: input.visible ?? true
    }
    
    console.log('createMemoItem入力:', itemInput)
    
    const response = await client.graphql({
      query: CREATE_MEMO_ITEM,
      variables: { 
        input: itemInput,
        // conditionは省略可能
      }
    }) as GraphQLResult<CreateMemoItemResponse>
    
    console.log('createMemoItemレスポンス:', response)
    
    const createdItem = response.data?.createMemoItem
    if (!createdItem) {
      throw new Error('作成されたアイテムが取得できませんでした')
    }
    
    return {
      success: true,
      item: convertAmplifyToMemoItem(createdItem)
    }
  } catch (error) {
    console.error('メモ項目の作成に失敗:', error)
    // エラーの詳細をログ出力
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLエラーの詳細:', (error as any).errors)
    }
    return {
      success: false,
      error: 'メモ項目の作成に失敗しました'
    }
  }
}

/**
 * メモ項目を更新します
 * 
 * @param input - 更新するメモ項目の情報
 * @returns Promise<MemoItemOperationResult> 更新結果
 */
export async function updateMemoItem(input: UpdateMemoItemInput): Promise<MemoItemOperationResult> {
  try {
    // 入力値の検証
    if (input.name !== undefined && !input.name.trim()) {
      return {
        success: false,
        error: 'メモ項目名を入力してください'
      }
    }
    
    // _versionは除外（Amplifyで自動管理）
    const updateInput = {
      id: input.id,
      ...(input.name && { name: input.name.trim() }),
      ...(input.order !== undefined && { order: input.order }),
      ...(input.visible !== undefined && { visible: input.visible })
    }
    
    console.log('updateMemoItem入力:', updateInput)
    
    const response = await client.graphql({
      query: UPDATE_MEMO_ITEM,
      variables: { 
        input: updateInput,
        // conditionは省略可能
      }
    }) as GraphQLResult<UpdateMemoItemResponse>
    
    console.log('updateMemoItemレスポンス:', response)
    
    const updatedItem = response.data?.updateMemoItem
    if (!updatedItem) {
      throw new Error('更新されたアイテムが取得できませんでした')
    }
    
    return {
      success: true,
      item: convertAmplifyToMemoItem(updatedItem)
    }
  } catch (error) {
    console.error('メモ項目の更新に失敗:', error)
    // エラーの詳細をログ出力
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLエラーの詳細:', (error as any).errors)
    }
    return {
      success: false,
      error: 'メモ項目の更新に失敗しました'
    }
  }
}

/**
 * メモ項目を削除します
 * 
 * @param input - 削除するメモ項目の情報
 * @returns Promise<MemoItemOperationResult> 削除結果
 */
export async function deleteMemoItem(input: DeleteMemoItemInput): Promise<MemoItemOperationResult> {
  try {
    // _versionは除外（Amplifyで自動管理）
    const deleteInput = {
      id: input.id
    }
    
    console.log('deleteMemoItem入力:', deleteInput)
    
    await client.graphql({
      query: DELETE_MEMO_ITEM,
      variables: { 
        input: deleteInput,
        // conditionは省略可能
      }
    }) as GraphQLResult<DeleteMemoItemResponse>
    
    return {
      success: true
    }
  } catch (error) {
    console.error('メモ項目の削除に失敗:', error)
    // エラーの詳細をログ出力
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLエラーの詳細:', (error as any).errors)
    }
    return {
      success: false,
      error: 'メモ項目の削除に失敗しました'
    }
  }
}

/**
 * 複数のメモ項目の順序を一括更新します
 * 
 * ドラッグ&ドロップ操作後の順序保存で使用します。
 * 
 * @param items - 更新するメモ項目のリスト
 * @returns Promise<MemoItemOperationResult> 更新結果
 */
export async function bulkUpdateMemoItemOrder(items: Array<{
  id: string
  order: number
}>): Promise<MemoItemOperationResult> {
  console.log('🔧 bulkUpdateMemoItemOrder 開始:', { 
    itemCount: items.length, 
    items: items 
  })

  try {
    if (items.length === 0) {
      console.log('⚠️ 更新対象項目が0個')
      return {
        success: true
      }
    }

    console.log('📤 GraphQL更新リクエスト準備中...')

    // 全項目の順序を並列で更新（_versionは除外）
    const updatePromises = items.map((item, index) => {
      console.log(`📝 更新項目 ${index + 1}/${items.length}:`, item)
      return client.graphql({
        query: UPDATE_MEMO_ITEM,
        variables: { 
          input: { 
            id: item.id,
            order: item.order
          }
        }
      }) as unknown as GraphQLResult<UpdateMemoItemResponse>
    })
    
    console.log('⏳ Promise.all実行中...')
    const results = await Promise.all(updatePromises)
    console.log('✅ 全ての更新が完了:', { 
      successCount: results.length,
      results: results.map(r => !!r.data?.updateMemoItem)
    })
    
    return {
      success: true
    }
  } catch (error) {
    console.error('❌ メモ項目の順序更新に失敗:', error)
    // エラーの詳細をログ出力
    if (error && typeof error === 'object' && 'errors' in error) {
      console.error('GraphQLエラーの詳細:', (error as any).errors)
    }
    return {
      success: false,
      error: 'メモ項目の順序更新に失敗しました'
    }
  }
}

/**
 * 新しいメモ項目の適切な順序を取得します
 * 
 * 既存の項目の最大order値 + 1を返します。
 * 
 * @returns Promise<number> 新しい項目に設定すべき順序
 */
export async function getNextOrder(): Promise<number> {
  try {
    const result = await getMemoItems({ visibleOnly: false })
    
    if (result.items.length === 0) {
      return 0
    }
    
    const maxOrder = Math.max(...result.items.map(item => item.order))
    return maxOrder + 1
  } catch (error) {
    console.error('次の順序の取得に失敗:', error)
    // エラー時は0を返す（最初の項目として扱う）
    return 0
  }
} 